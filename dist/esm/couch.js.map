{"version":3,"file":"couch.js","sources":["../../src/couch.ts"],"sourcesContent":["import { CollectionConfig, OperationType, ResolveType } from \"@tanstack/db\";\nimport { Store } from \"@tanstack/store\";\n\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport {\n  CouchDBCollectionError,\n  CouchDBRequestFailedError,\n  DocumentNotFoundError,\n  InitialSyncFailedError,\n  NoIDProvidedError,\n  TimeoutWaitingForDeleteError,\n  TimeoutWaitingForInsertError,\n  TimeoutWaitingForUpdateError,\n} from \"./errors\";\n\ntype PouchDBCoreDoc = PouchDB.Core.ExistingDocument<PouchDB.Core.AllDocsMeta>;\n\nexport interface CouchDBCollectionConfig<\n  TExplicit extends unknown = unknown,\n  TSchema extends StandardSchemaV1 = never,\n  TFallback extends PouchDBCoreDoc = PouchDBCoreDoc,\n> extends Omit<\n    CollectionConfig<\n      ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc\n    >,\n    \"onInsert\" | \"onUpdate\" | \"onDelete\" | \"sync\" | \"getKey\"\n  > {\n  couch: {\n    db: PouchDB.Database;\n    filter?: (doc: PouchDBCoreDoc & object) => boolean;\n    attachments?: boolean;\n    binary?: boolean;\n    mutationTimeout?: number;\n  };\n}\n\nconst rejectAfterSleep = (sleepTime: number, error: CouchDBCollectionError) =>\n  new Promise((_resolve, reject) => {\n    setTimeout(() => {\n      reject(error);\n    }, sleepTime);\n  });\n\nconst createChangeTrackingId = (id: string, rev: string) => `${id}:${rev}`;\n\nexport function couchDBCollectionOptions<\n  TExplicit extends unknown = unknown,\n  TSchema extends StandardSchemaV1 = never,\n  TFallback extends PouchDBCoreDoc = PouchDBCoreDoc,\n>({\n  couch: {\n    db,\n    mutationTimeout = 10_000,\n    filter = (doc) => !doc._id.startsWith(\"_\"),\n    attachments = false,\n    binary = false,\n  },\n  ...config\n}: CouchDBCollectionConfig<TExplicit, TSchema, TFallback>): CollectionConfig<\n  ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc\n> {\n  const seenDocumentIds = new Store<Set<string>>(new Set());\n  const awaitDocumentUpdate = (trackingId: string): Promise<boolean> => {\n    if (seenDocumentIds.state.has(trackingId)) return Promise.resolve(true);\n\n    return new Promise((resolve) => {\n      const unsubscribe = seenDocumentIds.subscribe(() => {\n        if (seenDocumentIds.state.has(trackingId)) {\n          // is this safe?\n          seenDocumentIds.state.delete(trackingId);\n\n          unsubscribe();\n          resolve(true);\n        }\n      });\n    });\n  };\n\n  const sync: CollectionConfig<\n    ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc\n  >[`sync`][`sync`] = (params) => {\n    const {\n      begin,\n      write: unfilteredWrite,\n      commit,\n      markReady,\n      collection,\n    } = params;\n    const write: typeof unfilteredWrite = (event) =>\n      filter(event.value) ? unfilteredWrite(event) : undefined;\n\n    const eventBuffer: Array<{\n      type: OperationType;\n      value: ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc;\n    }> = [];\n    let isInitialSyncComplete = false;\n\n    // 1. Initialize connection to sync engine\n    const pouchChangeListener = db\n      .changes<ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc>({\n        since: \"now\",\n        live: true,\n        include_docs: true,\n        attachments,\n        binary,\n      })\n      .on(\"change\", (change) => {\n        if (!change.doc) {\n          throw new CouchDBCollectionError(\n            \"Doc was not returned with the change, THIS SHOULD NEVER HAPPEN\",\n          );\n        }\n        const doc = change.doc;\n\n        let operationType: OperationType = \"update\";\n        if (change.deleted) operationType = \"delete\";\n        else if (collection.get(doc._id) == null) operationType = \"insert\";\n\n        if (!isInitialSyncComplete) {\n          // Buffer events during initial sync to prevent race conditions\n          eventBuffer.push({ type: operationType, value: doc });\n          return;\n        }\n\n        begin();\n\n        seenDocumentIds.setState((prevState) => {\n          return prevState.add(createChangeTrackingId(doc._id, doc._rev));\n        });\n        write({ type: operationType, value: doc });\n\n        commit();\n      });\n\n    // 3. Perform initial data fetch\n    async function initialSync() {\n      try {\n        const data = await db.allDocs<\n          ResolveType<TExplicit, TSchema, TFallback>\n        >({\n          include_docs: true,\n          attachments,\n          binary,\n        });\n\n        begin(); // Start a transaction\n\n        for (const item of data.rows) {\n          if (!item.doc)\n            throw new CouchDBCollectionError(\n              \"Doc was not returned when retrieving all docs, THIS SHOULD NEVER HAPPEN\",\n            );\n          write({\n            type: \"insert\",\n            value: item.doc,\n          });\n        }\n\n        commit(); // Commit the transaction\n\n        // 4. Process buffered events\n        isInitialSyncComplete = true;\n        if (eventBuffer.length > 0) {\n          begin();\n\n          for (const event of eventBuffer) {\n            write(event);\n          }\n          commit();\n          eventBuffer.splice(0);\n        }\n      } catch (error) {\n        throw new InitialSyncFailedError(error);\n      } finally {\n        // ALWAYS call markReady, even on error\n        markReady();\n      }\n    }\n\n    initialSync();\n\n    return () => pouchChangeListener.cancel();\n  };\n\n  const handleCouchUpdate = async (\n    handler: () => Promise<PouchDB.Core.Response>,\n  ) => {\n    let res = undefined;\n    try {\n      res = await handler();\n    } catch (e) {\n      throw new CouchDBRequestFailedError(e);\n    }\n\n    const trackingId = createChangeTrackingId(res.id, res.rev);\n    await awaitDocumentUpdate(trackingId);\n  };\n\n  const promiseAllWithTimeout = (\n    ps: Promise<any>[],\n    error: CouchDBCollectionError,\n  ) =>\n    Promise.race([\n      mutationTimeout && rejectAfterSleep(mutationTimeout, error),\n      Promise.all(ps),\n    ]);\n\n  return {\n    id: config.id,\n    getKey: (item) => item._id,\n    schema: config.schema,\n    sync: { sync, rowUpdateMode: \"full\" },\n    onDelete: async ({ transaction, collection }) => {\n      // We must get the doc as a deletion requires a revision id\n      await promiseAllWithTimeout(\n        transaction.mutations.map(async (mutation) => {\n          if (!mutation.changes._id)\n            throw new NoIDProvidedError(mutation.changes);\n\n          const doc = collection.get(mutation.changes._id);\n          if (!doc) throw new DocumentNotFoundError(mutation.changes._id);\n\n          await handleCouchUpdate(async () => db.remove(doc._id, doc._rev));\n        }),\n        new TimeoutWaitingForDeleteError(\n          transaction.mutations.map((mut) => mut.changes._id!),\n        ),\n      );\n    },\n    onUpdate: async ({ transaction, collection }) => {\n      await promiseAllWithTimeout(\n        transaction.mutations.map(async (mutation) => {\n          if (!mutation.changes._id)\n            throw new NoIDProvidedError(mutation.changes);\n\n          const doc = collection.get(mutation.changes._id);\n          if (!doc) throw new DocumentNotFoundError(mutation.changes._id);\n\n          await handleCouchUpdate(() =>\n            db.put({ ...mutation.changes, _rev: doc._rev }),\n          );\n        }),\n        new TimeoutWaitingForUpdateError(\n          transaction.mutations.map((mut) => mut.changes._id!),\n        ),\n      );\n    },\n    onInsert: async ({ transaction }) => {\n      await promiseAllWithTimeout(\n        transaction.mutations.map(async (mutation) => {\n          if (!mutation.changes._id)\n            throw new NoIDProvidedError(mutation.changes);\n\n          await handleCouchUpdate(async () => db.put(mutation.changes));\n        }),\n\n        new TimeoutWaitingForInsertError(\n          transaction.mutations.map((mut) => mut.changes._id!),\n        ),\n      );\n    },\n  };\n}\n"],"names":[],"mappings":";;AAoCA,MAAM,mBAAmB,CAAC,WAAmB,UAC3C,IAAI,QAAQ,CAAC,UAAU,WAAW;AAChC,aAAW,MAAM;AACf,WAAO,KAAK;AAAA,EACd,GAAG,SAAS;AACd,CAAC;AAEH,MAAM,yBAAyB,CAAC,IAAY,QAAgB,GAAG,EAAE,IAAI,GAAG;AAEjE,SAAS,yBAId;AAAA,EACA,OAAO;AAAA,IACL;AAAA,IACA,kBAAkB;AAAA,IAClB,SAAS,CAAC,QAAQ,CAAC,IAAI,IAAI,WAAW,GAAG;AAAA,IACzC,cAAc;AAAA,IACd,SAAS;AAAA,EAAA;AAAA,EAEX,GAAG;AACL,GAEE;AACA,QAAM,kBAAkB,IAAI,MAAmB,oBAAI,KAAK;AACxD,QAAM,sBAAsB,CAAC,eAAyC;AACpE,QAAI,gBAAgB,MAAM,IAAI,UAAU,EAAG,QAAO,QAAQ,QAAQ,IAAI;AAEtE,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,YAAM,cAAc,gBAAgB,UAAU,MAAM;AAClD,YAAI,gBAAgB,MAAM,IAAI,UAAU,GAAG;AAEzC,0BAAgB,MAAM,OAAO,UAAU;AAEvC,sBAAA;AACA,kBAAQ,IAAI;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAEA,QAAM,OAEc,CAAC,WAAW;AAC9B,UAAM;AAAA,MACJ;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,IAAA,IACE;AACJ,UAAM,QAAgC,CAAC,UACrC,OAAO,MAAM,KAAK,IAAI,gBAAgB,KAAK,IAAI;AAEjD,UAAM,cAGD,CAAA;AACL,QAAI,wBAAwB;AAG5B,UAAM,sBAAsB,GACzB,QAAqE;AAAA,MACpE,OAAO;AAAA,MACP,MAAM;AAAA,MACN,cAAc;AAAA,MACd;AAAA,MACA;AAAA,IAAA,CACD,EACA,GAAG,UAAU,CAAC,WAAW;AACxB,UAAI,CAAC,OAAO,KAAK;AACf,cAAM,IAAI;AAAA,UACR;AAAA,QAAA;AAAA,MAEJ;AACA,YAAM,MAAM,OAAO;AAEnB,UAAI,gBAA+B;AACnC,UAAI,OAAO,QAAS,iBAAgB;AAAA,eAC3B,WAAW,IAAI,IAAI,GAAG,KAAK,KAAM,iBAAgB;AAE1D,UAAI,CAAC,uBAAuB;AAE1B,oBAAY,KAAK,EAAE,MAAM,eAAe,OAAO,KAAK;AACpD;AAAA,MACF;AAEA,YAAA;AAEA,sBAAgB,SAAS,CAAC,cAAc;AACtC,eAAO,UAAU,IAAI,uBAAuB,IAAI,KAAK,IAAI,IAAI,CAAC;AAAA,MAChE,CAAC;AACD,YAAM,EAAE,MAAM,eAAe,OAAO,KAAK;AAEzC,aAAA;AAAA,IACF,CAAC;AAGH,mBAAe,cAAc;AAC3B,UAAI;AACF,cAAM,OAAO,MAAM,GAAG,QAEpB;AAAA,UACA,cAAc;AAAA,UACd;AAAA,UACA;AAAA,QAAA,CACD;AAED,cAAA;AAEA,mBAAW,QAAQ,KAAK,MAAM;AAC5B,cAAI,CAAC,KAAK;AACR,kBAAM,IAAI;AAAA,cACR;AAAA,YAAA;AAEJ,gBAAM;AAAA,YACJ,MAAM;AAAA,YACN,OAAO,KAAK;AAAA,UAAA,CACb;AAAA,QACH;AAEA,eAAA;AAGA,gCAAwB;AACxB,YAAI,YAAY,SAAS,GAAG;AAC1B,gBAAA;AAEA,qBAAW,SAAS,aAAa;AAC/B,kBAAM,KAAK;AAAA,UACb;AACA,iBAAA;AACA,sBAAY,OAAO,CAAC;AAAA,QACtB;AAAA,MACF,SAAS,OAAO;AACd,cAAM,IAAI,uBAAuB,KAAK;AAAA,MACxC,UAAA;AAEE,kBAAA;AAAA,MACF;AAAA,IACF;AAEA,gBAAA;AAEA,WAAO,MAAM,oBAAoB,OAAA;AAAA,EACnC;AAEA,QAAM,oBAAoB,OACxB,YACG;AACH,QAAI,MAAM;AACV,QAAI;AACF,YAAM,MAAM,QAAA;AAAA,IACd,SAAS,GAAG;AACV,YAAM,IAAI,0BAA0B,CAAC;AAAA,IACvC;AAEA,UAAM,aAAa,uBAAuB,IAAI,IAAI,IAAI,GAAG;AACzD,UAAM,oBAAoB,UAAU;AAAA,EACtC;AAEA,QAAM,wBAAwB,CAC5B,IACA,UAEA,QAAQ,KAAK;AAAA,IACX,mBAAmB,iBAAiB,iBAAiB,KAAK;AAAA,IAC1D,QAAQ,IAAI,EAAE;AAAA,EAAA,CACf;AAEH,SAAO;AAAA,IACL,IAAI,OAAO;AAAA,IACX,QAAQ,CAAC,SAAS,KAAK;AAAA,IACvB,QAAQ,OAAO;AAAA,IACf,MAAM,EAAE,MAAM,eAAe,OAAA;AAAA,IAC7B,UAAU,OAAO,EAAE,aAAa,iBAAiB;AAE/C,YAAM;AAAA,QACJ,YAAY,UAAU,IAAI,OAAO,aAAa;AAC5C,cAAI,CAAC,SAAS,QAAQ;AACpB,kBAAM,IAAI,kBAAkB,SAAS,OAAO;AAE9C,gBAAM,MAAM,WAAW,IAAI,SAAS,QAAQ,GAAG;AAC/C,cAAI,CAAC,IAAK,OAAM,IAAI,sBAAsB,SAAS,QAAQ,GAAG;AAE9D,gBAAM,kBAAkB,YAAY,GAAG,OAAO,IAAI,KAAK,IAAI,IAAI,CAAC;AAAA,QAClE,CAAC;AAAA,QACD,IAAI;AAAA,UACF,YAAY,UAAU,IAAI,CAAC,QAAQ,IAAI,QAAQ,GAAI;AAAA,QAAA;AAAA,MACrD;AAAA,IAEJ;AAAA,IACA,UAAU,OAAO,EAAE,aAAa,iBAAiB;AAC/C,YAAM;AAAA,QACJ,YAAY,UAAU,IAAI,OAAO,aAAa;AAC5C,cAAI,CAAC,SAAS,QAAQ;AACpB,kBAAM,IAAI,kBAAkB,SAAS,OAAO;AAE9C,gBAAM,MAAM,WAAW,IAAI,SAAS,QAAQ,GAAG;AAC/C,cAAI,CAAC,IAAK,OAAM,IAAI,sBAAsB,SAAS,QAAQ,GAAG;AAE9D,gBAAM;AAAA,YAAkB,MACtB,GAAG,IAAI,EAAE,GAAG,SAAS,SAAS,MAAM,IAAI,KAAA,CAAM;AAAA,UAAA;AAAA,QAElD,CAAC;AAAA,QACD,IAAI;AAAA,UACF,YAAY,UAAU,IAAI,CAAC,QAAQ,IAAI,QAAQ,GAAI;AAAA,QAAA;AAAA,MACrD;AAAA,IAEJ;AAAA,IACA,UAAU,OAAO,EAAE,kBAAkB;AACnC,YAAM;AAAA,QACJ,YAAY,UAAU,IAAI,OAAO,aAAa;AAC5C,cAAI,CAAC,SAAS,QAAQ;AACpB,kBAAM,IAAI,kBAAkB,SAAS,OAAO;AAE9C,gBAAM,kBAAkB,YAAY,GAAG,IAAI,SAAS,OAAO,CAAC;AAAA,QAC9D,CAAC;AAAA,QAED,IAAI;AAAA,UACF,YAAY,UAAU,IAAI,CAAC,QAAQ,IAAI,QAAQ,GAAI;AAAA,QAAA;AAAA,MACrD;AAAA,IAEJ;AAAA,EAAA;AAEJ;"}