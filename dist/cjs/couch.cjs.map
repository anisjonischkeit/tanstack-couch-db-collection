{"version":3,"file":"couch.cjs","sources":["../../src/couch.ts"],"sourcesContent":["import { CollectionConfig, OperationType, ResolveType } from \"@tanstack/db\";\nimport { Store } from \"@tanstack/store\";\n\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport {\n  CouchDBCollectionError,\n  CouchDBRequestFailedError,\n  DocumentNotFoundError,\n  InitialSyncFailedError,\n  NoIDProvidedError,\n  TimeoutWaitingForDeleteError,\n  TimeoutWaitingForInsertError,\n  TimeoutWaitingForUpdateError,\n} from \"./errors\";\n\ntype PouchDBCoreDoc = PouchDB.Core.ExistingDocument<PouchDB.Core.AllDocsMeta>;\n\nexport interface CouchDBCollectionConfig<\n  TExplicit extends unknown = unknown,\n  TSchema extends StandardSchemaV1 = never,\n  TFallback extends PouchDBCoreDoc = PouchDBCoreDoc,\n> extends Omit<\n    CollectionConfig<\n      ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc\n    >,\n    \"onInsert\" | \"onUpdate\" | \"onDelete\" | \"sync\" | \"getKey\"\n  > {\n  db: PouchDB.Database;\n  mutationTimeout?: number;\n}\n\nconst rejectAfterSleep = (sleepTime: number, error: CouchDBCollectionError) =>\n  new Promise((_resolve, reject) => {\n    setTimeout(() => {\n      reject(error);\n    }, sleepTime);\n  });\n\nconst createChangeTrackingId = (id: string, rev: string) => `${id}:${rev}`;\n\nexport function couchDBCollectionOptions<\n  TExplicit extends unknown = unknown,\n  TSchema extends StandardSchemaV1 = never,\n  TFallback extends PouchDBCoreDoc = PouchDBCoreDoc,\n>(\n  config: CouchDBCollectionConfig<TExplicit, TSchema, TFallback>,\n): CollectionConfig<\n  ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc\n> {\n  const createWriteData = (change: {\n    deleted?: boolean;\n    doc: ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc;\n  }): {\n    type: OperationType;\n    value: ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc;\n  } => {\n    if (change.deleted) {\n      return {\n        type: \"delete\",\n        value: change.doc,\n      };\n    } else {\n      // Check the revision number to distinguish insert from update\n      if (change.doc!._rev.startsWith(\"1-\")) {\n        return {\n          type: \"insert\",\n          value: change.doc,\n        };\n      } else {\n        return {\n          type: \"update\",\n          value: change.doc,\n        };\n      }\n    }\n  };\n\n  const seenDocumentIds = new Store<Set<string>>(new Set());\n  const awaitDocumentUpdate = (trackingId: string): Promise<boolean> => {\n    if (seenDocumentIds.state.has(trackingId)) return Promise.resolve(true);\n\n    return new Promise((resolve) => {\n      const unsubscribe = seenDocumentIds.subscribe(() => {\n        if (seenDocumentIds.state.has(trackingId)) {\n          // is this safe?\n          seenDocumentIds.state.delete(trackingId);\n\n          unsubscribe();\n          resolve(true);\n        }\n      });\n    });\n  };\n\n  const sync: CollectionConfig<\n    ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc\n  >[`sync`][`sync`] = (params) => {\n    const { begin, write, commit, markReady, collection } = params;\n\n    const eventBuffer: Array<any> = [];\n    let isInitialSyncComplete = false;\n\n    // 1. Initialize connection to sync engine\n    const pouchChangeListener = config.db\n      .changes<ResolveType<TExplicit, TSchema, TFallback> & PouchDBCoreDoc>({\n        since: \"now\",\n        live: true,\n        include_docs: true,\n      })\n      .on(\"change\", (change) => {\n        if (!change.doc) {\n          throw new CouchDBCollectionError(\n            \"Doc was not returned with the change, THIS SHOULD NEVER HAPPEN\",\n          );\n        }\n        const doc = change.doc;\n\n        if (!isInitialSyncComplete) {\n          // Buffer events during initial sync to prevent race conditions\n          eventBuffer.push(change);\n          return;\n        }\n\n        begin();\n\n        seenDocumentIds.setState((prevState) => {\n          return prevState.add(createChangeTrackingId(doc._id, doc._rev));\n        });\n        write(\n          createWriteData({\n            deleted: change.deleted,\n            doc: doc,\n          }),\n        );\n\n        commit();\n      });\n\n    // 3. Perform initial data fetch\n    async function initialSync() {\n      try {\n        const data = await config.db.allDocs<\n          ResolveType<TExplicit, TSchema, TFallback>\n        >({\n          include_docs: true,\n        });\n\n        begin(); // Start a transaction\n\n        for (const item of data.rows) {\n          if (!item.doc)\n            throw new CouchDBCollectionError(\n              \"Doc was not returned when retrieving all docs, THIS SHOULD NEVER HAPPEN\",\n            );\n          write({\n            type: \"insert\",\n            value: item.doc,\n          });\n        }\n\n        commit(); // Commit the transaction\n\n        // 4. Process buffered events\n        isInitialSyncComplete = true;\n        if (eventBuffer.length > 0) {\n          begin();\n\n          for (const event of eventBuffer) {\n            write(event);\n          }\n          commit();\n          eventBuffer.splice(0);\n        }\n      } catch (error) {\n        throw new InitialSyncFailedError(error);\n      } finally {\n        // ALWAYS call markReady, even on error\n        markReady();\n      }\n    }\n\n    initialSync();\n\n    return () => pouchChangeListener.cancel();\n  };\n\n  const handleCouchUpdate = async (\n    handler: () => Promise<PouchDB.Core.Response>,\n  ) => {\n    let res = undefined;\n    try {\n      res = await handler();\n    } catch (e) {\n      throw new CouchDBRequestFailedError(e);\n    }\n\n    const trackingId = createChangeTrackingId(res.id, res.rev);\n    await awaitDocumentUpdate(trackingId);\n  };\n\n  const promiseAllWithTimeout = (\n    ps: Promise<any>[],\n    error: CouchDBCollectionError,\n  ) =>\n    Promise.race([\n      config.mutationTimeout !== null &&\n        rejectAfterSleep(config.mutationTimeout || 10000, error),\n      Promise.all(ps),\n    ]);\n\n  return {\n    id: config.id,\n    getKey: (item) => item._id,\n    schema: config.schema,\n    sync: { sync },\n    onDelete: async ({ transaction, collection }) => {\n      // We must get the doc as a deletion requires a revision id\n      await promiseAllWithTimeout(\n        transaction.mutations.map(async (mutation) => {\n          if (!mutation.changes._id)\n            throw new NoIDProvidedError(mutation.changes);\n\n          const doc = collection.get(mutation.changes._id);\n          if (!doc) throw new DocumentNotFoundError(mutation.changes._id);\n\n          await handleCouchUpdate(async () =>\n            config.db.remove(doc._id, doc._rev),\n          );\n        }),\n        new TimeoutWaitingForDeleteError(\n          transaction.mutations.map((mut) => mut.changes._id!),\n        ),\n      );\n    },\n    onUpdate: async ({ transaction, collection }) => {\n      await promiseAllWithTimeout(\n        transaction.mutations.map(async (mutation) => {\n          if (!mutation.changes._id)\n            throw new NoIDProvidedError(mutation.changes);\n\n          const doc = collection.get(mutation.changes._id);\n          if (!doc) throw new DocumentNotFoundError(mutation.changes._id);\n\n          await handleCouchUpdate(() =>\n            config.db.put(transaction.mutations[0].changes),\n          );\n        }),\n        new TimeoutWaitingForUpdateError(\n          transaction.mutations.map((mut) => mut.changes._id!),\n        ),\n      );\n    },\n    onInsert: async ({ transaction }) => {\n      await promiseAllWithTimeout(\n        transaction.mutations.map(async (mutation) => {\n          if (!mutation.changes._id)\n            throw new NoIDProvidedError(mutation.changes);\n\n          await handleCouchUpdate(async () => config.db.put(mutation.changes));\n        }),\n\n        new TimeoutWaitingForInsertError(\n          transaction.mutations.map((mut) => mut.changes._id!),\n        ),\n      );\n    },\n  };\n}\n"],"names":["Store","CouchDBCollectionError","InitialSyncFailedError","CouchDBRequestFailedError","NoIDProvidedError","DocumentNotFoundError","TimeoutWaitingForDeleteError","TimeoutWaitingForUpdateError","TimeoutWaitingForInsertError"],"mappings":"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"}